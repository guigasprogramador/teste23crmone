CREATE DATABASE IF NOT EXISTS `crmone-teste` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE `crmone-teste`;

SET FOREIGN_KEY_CHECKS=0; -- Disable temporarily to handle potential ordering issues within large DDLs

-- Content from auth_mysql.sql
-- MySQL DDL for Authentication Tables

-- Users table
CREATE TABLE IF NOT EXISTS users (
  id CHAR(36) PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE,
  password VARCHAR(255),
  microsoft_id VARCHAR(255) UNIQUE,
  avatar_url VARCHAR(500),
  role VARCHAR(50) NOT NULL DEFAULT 'user',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Index on email for users table
CREATE INDEX idx_users_email ON users(email);

-- User Profiles table
CREATE TABLE IF NOT EXISTS user_profiles (
  id CHAR(36) PRIMARY KEY,
  user_id CHAR(36) NOT NULL,
  bio TEXT,
  phone VARCHAR(20),
  address TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Index on user_id for user_profiles table
CREATE INDEX idx_user_profiles_user_id ON user_profiles(user_id);

-- User Preferences table
CREATE TABLE IF NOT EXISTS user_preferences (
  id CHAR(36) PRIMARY KEY,
  user_id CHAR(36) NOT NULL,
  email_notifications TINYINT(1) DEFAULT 1, -- 1 for TRUE, 0 for FALSE
  sms_notifications TINYINT(1) DEFAULT 0,   -- 1 for TRUE, 0 for FALSE
  theme VARCHAR(20) DEFAULT 'light',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Index on user_id for user_preferences table
CREATE INDEX idx_user_preferences_user_id ON user_preferences(user_id);

-- Refresh tokens table
CREATE TABLE IF NOT EXISTS refresh_tokens (
  id CHAR(36) PRIMARY KEY,
  user_id CHAR(36) NOT NULL,
  token TEXT NOT NULL, -- TEXT can store long tokens; consider VARCHAR(length) if max length known
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP NOT NULL,
  is_revoked TINYINT(1) DEFAULT 0, -- 1 for TRUE, 0 for FALSE
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Index on user_id for refresh_tokens table
CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
-- Note: Indexing a TEXT column directly like in idx_refresh_tokens_token might not be efficient or allowed on all MySQL versions/configurations without specifying a prefix length.
-- If token is TEXT and needs to be unique and indexed for fast lookups, consider:
-- 1. Using VARCHAR with a reasonable max length if possible.
-- 2. Creating a HASH of the token and indexing that.
-- 3. Adding a UNIQUE constraint on the token column if it's VARCHAR.
-- For now, omitting direct index on TEXT token, but adding UNIQUE constraint.
ALTER TABLE refresh_tokens ADD CONSTRAINT uq_refresh_tokens_token UNIQUE (token(255)); -- Max prefix length for InnoDB is often 767 bytes or 3072 bytes depending on version/settings. 255 for UTF8MB4 char.

-- Roles table
CREATE TABLE IF NOT EXISTS roles (
  id CHAR(36) PRIMARY KEY,
  name VARCHAR(50) NOT NULL UNIQUE,
  description TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Permissions table
CREATE TABLE IF NOT EXISTS permissions (
  id CHAR(36) PRIMARY KEY,
  name VARCHAR(100) NOT NULL UNIQUE,
  description TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Role permissions junction table
CREATE TABLE IF NOT EXISTS role_permissions (
  role_id CHAR(36) NOT NULL,
  permission_id CHAR(36) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (role_id, permission_id),
  FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
  FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
);

-- Notes on omitted items:
-- 1. Default UUID generation: `uuid_generate_v4()` is PostgreSQL specific.
--    In MySQL, UUIDs should be generated by the application (recommended) or using `UUID()` function if MySQL 8.0+.
--    The DDL uses `CHAR(36)` for UUID columns.
-- 2. `update_updated_at_column` trigger: MySQL can handle automatic `updated_at` using `ON UPDATE CURRENT_TIMESTAMP`.
--    This has been added to `users`, `user_profiles`, and `user_preferences` tables.
-- 3. `cleanup_expired_tokens` function and cron job: This logic needs to be implemented separately,
--    e.g., as a scheduled event in MySQL or an application-level background job.
-- 4. `INSERT` statements and `DO $$ ... END $$;` blocks for initial data: These are omitted from DDL.
--    Data should be inserted via separate scripts or application logic.
-- 5. RLS policies: MySQL does not have Row Level Security in the same way as PostgreSQL.
--    Access control is typically managed via GRANT/REVOKE permissions at table/column level,
--    or implemented in the application layer or using views with definer rights.
-- 6. `crmonefactory` schema: The DDL does not prefix table names with a schema/database name.
--    This should be handled by connecting to the correct database before running the script
--    or by adding `database_name.` prefix to table names if needed.
-- 7. `users_id_fkey` constraint removal from `crmonefactory.users`: This seems to be a fix for an existing Supabase setup and is not part of the core DDL generation for new tables.
-- 8. `microsoft_id` in `users` table from `auth-schema.sql` was kept.
-- 9. `role` column in `users` table from `auth-schema.sql` was kept (VARCHAR(50) DEFAULT 'user').
--    The `solution-final-ajustado.sql` had `VARCHAR(20)`. Preference given to `auth-schema.sql`.
-- 10. `refresh_tokens.token` was `TEXT` in `auth-schema.sql` and `VARCHAR(255)` in `solution-final-ajustado.sql`.
--     Used `TEXT` as per `auth-schema.sql` but added a note about indexing and uniqueness.
--     Added a UNIQUE constraint with prefix for the TEXT token.
-- 11. `is_revoked` in `refresh_tokens` from `auth-schema.sql` was kept.
-- 12. `avatar_url` in `users` was VARCHAR(500) in `auth-schema.sql` and VARCHAR(255) in `solution-final-ajustado.sql`.
--     Used VARCHAR(500) as per `auth-schema.sql`.
-- 13. `password` in `users` was `VARCHAR(255)` in `auth-schema.sql` and `VARCHAR(255) NOT NULL` in `solution-final-ajustado.sql`.
--     Used `VARCHAR(255)` (nullable) as per `auth-schema.sql` as some auth methods (e.g. Microsoft ID) might not use a local password.
-- 14. `created_at` and `updated_at` for `user_profiles` and `user_preferences` are set to `DEFAULT CURRENT_TIMESTAMP` and `ON UPDATE CURRENT_TIMESTAMP` for `updated_at`.
-- 15. `user_id` foreign keys in `user_profiles`, `user_preferences`, `refresh_tokens` all point to `users(id) ON DELETE CASCADE`.
-- 16. Dropped `IF EXISTS` from `CREATE INDEX` as it's not standard in MySQL (index creation will fail if it exists).
--     Table creation uses `IF NOT EXISTS`.
-- 17. `PRIMARY KEY` for `id` columns are defined directly.
-- 18. `UNIQUE` constraints are defined directly for columns like `email`, `name` in `roles`/`permissions`.

/*
-- Example of how to insert a UUID in MySQL 8.0+ if needed (or generate in app):
-- INSERT INTO users (id, name, email, password, role)
-- VALUES (UUID(), 'Test User', 'test@example.com', 'password123', 'user');
*/

-- Content from licitacoes_mysql.sql
-- MySQL DDL for Licitacoes Module Tables

-- Table: orgaos (Government Entities)
CREATE TABLE IF NOT EXISTS orgaos (
  id CHAR(36) PRIMARY KEY,
  nome VARCHAR(255) NOT NULL,
  tipo VARCHAR(100),
  cnpj VARCHAR(20),
  endereco TEXT,
  cidade VARCHAR(100),
  estado VARCHAR(2), -- Assuming UF, e.g., SP, RJ
  segmento VARCHAR(100),
  origem_lead VARCHAR(100),
  responsavel_interno CHAR(36), -- FK to users table
  descricao TEXT,
  observacoes TEXT,
  faturamento VARCHAR(100), -- Consider a more structured type if used for calculations
  data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  data_atualizacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  ativo TINYINT(1) DEFAULT 1,
  FOREIGN KEY (responsavel_interno) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX idx_orgaos_cnpj ON orgaos(cnpj);
CREATE INDEX idx_orgaos_responsavel_interno ON orgaos(responsavel_interno);

-- Table: orgao_contatos (Contacts for Government Entities)
CREATE TABLE IF NOT EXISTS orgao_contatos (
  id CHAR(36) PRIMARY KEY,
  orgao_id CHAR(36) NOT NULL,
  nome VARCHAR(255) NOT NULL,
  cargo VARCHAR(100),
  email VARCHAR(255),
  telefone VARCHAR(20),
  data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  data_atualizacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (orgao_id) REFERENCES orgaos(id) ON DELETE CASCADE
);
CREATE INDEX idx_orgao_contatos_orgao_id ON orgao_contatos(orgao_id);
CREATE INDEX idx_orgao_contatos_email ON orgao_contatos(email);

-- Table: licitacoes (Bids/Tenders)
CREATE TABLE IF NOT EXISTS licitacoes (
  id CHAR(36) PRIMARY KEY,
  titulo VARCHAR(255) NOT NULL,
  orgao_id CHAR(36) NOT NULL,
  status VARCHAR(50) DEFAULT 'analise_interna',
  data_abertura TIMESTAMP NULL,
  data_publicacao TIMESTAMP NULL,
  data_julgamento TIMESTAMP NULL,
  valor_estimado DECIMAL(15, 2),
  valor_proposta DECIMAL(15, 2),
  modalidade VARCHAR(100) NOT NULL,
  objeto TEXT,
  edital VARCHAR(255), -- Path or identifier for the bid notice document
  numero_edital VARCHAR(100),
  responsavel_id CHAR(36), -- FK to users table (internal responsible user)
  prazo VARCHAR(100), -- Can be a specific date or description like "45 dias"
  url_licitacao TEXT, -- URL to the official bid page
  url_edital TEXT, -- Direct URL to the bid notice document
  descricao TEXT,
  forma_pagamento TEXT,
  obs_financeiras TEXT,
  tipo VARCHAR(20), -- 'produto' ou 'servico'
  tipo_faturamento VARCHAR(20), -- 'direto' ou 'distribuidor'
  margem_lucro DECIMAL(5, 2), -- Percentage, e.g., 15.50 for 15.50%
  contato_nome VARCHAR(255), -- External contact for this specific bid
  contato_email VARCHAR(255),
  contato_telefone VARCHAR(20),
  posicao_kanban INT DEFAULT 0,
  data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  data_atualizacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (orgao_id) REFERENCES orgaos(id) ON DELETE CASCADE,
  FOREIGN KEY (responsavel_id) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX idx_licitacoes_status ON licitacoes(status);
CREATE INDEX idx_licitacoes_orgao_id ON licitacoes(orgao_id);
CREATE INDEX idx_licitacoes_responsavel_id ON licitacoes(responsavel_id);
CREATE INDEX idx_licitacoes_data_abertura ON licitacoes(data_abertura);
CREATE INDEX idx_licitacoes_modalidade ON licitacoes(modalidade);

-- Table: licitacao_responsaveis (Many-to-many for multiple internal users responsible for a bid)
CREATE TABLE IF NOT EXISTS licitacao_responsaveis (
  id CHAR(36) PRIMARY KEY,
  licitacao_id CHAR(36) NOT NULL,
  usuario_id CHAR(36) NOT NULL, -- FK to users table
  papel VARCHAR(50), -- e.g., 'principal', 'suporte', 'financeiro'
  data_atribuicao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (licitacao_id) REFERENCES licitacoes(id) ON DELETE CASCADE,
  FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE CASCADE,
  UNIQUE KEY uq_licitacao_usuario (licitacao_id, usuario_id)
);
CREATE INDEX idx_licitacao_responsaveis_licitacao_id ON licitacao_responsaveis(licitacao_id);
CREATE INDEX idx_licitacao_responsaveis_usuario_id ON licitacao_responsaveis(usuario_id);

-- Table: licitacao_etapas (Stages or phases of a bid process)
CREATE TABLE IF NOT EXISTS licitacao_etapas (
  id CHAR(36) PRIMARY KEY,
  licitacao_id CHAR(36) NOT NULL,
  nome VARCHAR(100) NOT NULL,
  descricao TEXT,
  data_limite TIMESTAMP NULL, -- Deadline for this stage
  status VARCHAR(20) DEFAULT 'pendente', -- 'pendente', 'concluida', 'atrasada'
  responsavel_id CHAR(36), -- FK to users table (internal user responsible for this stage)
  observacoes TEXT,
  data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  data_conclusao TIMESTAMP NULL,
  FOREIGN KEY (licitacao_id) REFERENCES licitacoes(id) ON DELETE CASCADE,
  FOREIGN KEY (responsavel_id) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX idx_licitacao_etapas_licitacao_id ON licitacao_etapas(licitacao_id);
CREATE INDEX idx_licitacao_etapas_status ON licitacao_etapas(status);
CREATE INDEX idx_licitacao_etapas_responsavel_id ON licitacao_etapas(responsavel_id);

-- Table: licitacao_historico (History/log of changes for a bid)
CREATE TABLE IF NOT EXISTS licitacao_historico (
  id CHAR(36) PRIMARY KEY,
  licitacao_id CHAR(36) NOT NULL,
  usuario_id CHAR(36), -- FK to users table (user who made the change)
  acao VARCHAR(50) NOT NULL, -- 'criacao', 'alteracao', 'mudanca_status', etc.
  descricao TEXT, -- Description of the action
  dados_antigos JSON, -- Store previous state of relevant fields (MySQL JSON type)
  dados_novos JSON, -- Store new state of relevant fields (MySQL JSON type)
  data_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (licitacao_id) REFERENCES licitacoes(id) ON DELETE CASCADE,
  FOREIGN KEY (usuario_id) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX idx_licitacao_historico_licitacao_id ON licitacao_historico(licitacao_id);
CREATE INDEX idx_licitacao_historico_usuario_id ON licitacao_historico(usuario_id);
CREATE INDEX idx_licitacao_historico_acao ON licitacao_historico(acao);

-- ======================================
-- NOTES ON RECONCILIATION AND ASSUMPTIONS
-- ======================================
-- 1. `usuarios` Table:
--    The `crmonefactory.usuarios` table defined in the source schema (`licitacoes/01_tables.sql`)
--    has been IGNORED. All Foreign Keys originally pointing to it now point to the
--    central `users` table (assumed to be named `users` and exist in the same database).
--    This includes:
--      - `orgaos.responsavel_interno` -> `users(id)`
--      - `licitacoes.responsavel_id` -> `users(id)`
--      - `licitacao_responsaveis.usuario_id` -> `users(id)`
--      - `licitacao_etapas.responsavel_id` -> `users(id)`
--      - `licitacao_historico.usuario_id` -> `users(id)`

-- 2. `documentos` Table:
--    The `crmonefactory.documentos` table defined in the source schema (`licitacoes/01_tables.sql`)
--    has been IGNORED. It is assumed that the canonical `documentos` table DDL from the
--    "Documentos Module" (generated in a previous step) will be used. That `documentos`
--    table should already include a `licitacao_id CHAR(36)` column, allowing documents
--    to be linked to licitacoes. No separate `documentos` table is created here.

-- 3. `documento_categorias` Table:
--    The `crmonefactory.documento_categorias` table defined in the source schema
--    (`licitacoes/01_tables.sql`) has been IGNORED. It is assumed that the `tags` and
--    `documentos_tags` tables from the "Documentos Module" DDL will be used for
--    categorizing/tagging documents.

-- 4. General DDL Transformations:
--    - `UUID` type changed to `CHAR(36)`. UUIDs are expected to be generated by the application.
--    - `TIMESTAMP WITH TIME ZONE` changed to `TIMESTAMP`.
--    - `DEFAULT uuid_generate_v4()` removed.
--    - `DEFAULT now()` changed to `DEFAULT CURRENT_TIMESTAMP`.
--    - `data_atualizacao` columns have `ON UPDATE CURRENT_TIMESTAMP` where appropriate.
--    - `JSONB` type changed to `JSON` for MySQL compatibility.
--    - Schema prefix `crmonefactory.` removed from all table names.
--    - `CREATE SCHEMA` statement removed.
--    - Indexes are created using MySQL syntax.

/*
-- Example of how to insert a licitacao in MySQL:
-- INSERT INTO licitacoes (id, titulo, orgao_id, modalidade, responsavel_id)
-- VALUES (UUID(), 'Nova Licitação de TI', 'orgao-uuid', 'Pregão Eletrônico', 'user-uuid');
*/

-- Content from comercial_mysql.sql
-- MySQL DDL for Comercial Module Tables

-- Table: segmentos_clientes
CREATE TABLE IF NOT EXISTS segmentos_clientes (
  id CHAR(36) PRIMARY KEY,
  nome VARCHAR(100) NOT NULL UNIQUE,
  descricao TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Table: clientes
CREATE TABLE IF NOT EXISTS clientes (
  id CHAR(36) PRIMARY KEY,
  nome VARCHAR(255) NOT NULL,
  cnpj VARCHAR(20) NOT NULL UNIQUE,
  contato_nome VARCHAR(255),
  contato_telefone VARCHAR(20),
  contato_email VARCHAR(255),
  endereco VARCHAR(255),
  cidade VARCHAR(100),
  estado VARCHAR(2), -- Assuming UF, e.g., SP, RJ
  segmento VARCHAR(100), -- Consider FK to segmentos_clientes.nome or id if it becomes a managed list
  data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Retained from original, could be same as created_at
  ativo TINYINT(1) DEFAULT 1,
  descricao TEXT,
  observacoes TEXT,
  faturamento VARCHAR(100), -- Consider a more structured type if used for calculations (e.g., DECIMAL)
  responsavel_interno CHAR(36), -- FK to users table
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (responsavel_interno) REFERENCES users(id) ON DELETE SET NULL -- Or ON DELETE RESTRICT based on policy
);
CREATE INDEX idx_clientes_cnpj ON clientes(cnpj);
CREATE INDEX idx_clientes_responsavel_interno ON clientes(responsavel_interno);

-- Table: contatos
CREATE TABLE IF NOT EXISTS contatos (
  id CHAR(36) PRIMARY KEY,
  cliente_id CHAR(36),
  nome VARCHAR(255) NOT NULL,
  cargo VARCHAR(100),
  email VARCHAR(255),
  telefone VARCHAR(20),
  principal TINYINT(1) DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (cliente_id) REFERENCES clientes(id) ON DELETE CASCADE
);
CREATE INDEX idx_contatos_cliente_id ON contatos(cliente_id);
CREATE INDEX idx_contatos_email ON contatos(email);

-- Table: responsaveis (Internal Employees/Users responsible for commercial activities)
-- This table seems to duplicate user information from the main `users` table.
-- Consider if this table is truly needed or if `users` table with specific roles/permissions is sufficient.
-- If kept, user_id should be UNIQUE to avoid multiple profiles for the same user.
CREATE TABLE IF NOT EXISTS responsaveis (
  id CHAR(36) PRIMARY KEY, -- This could be user_id itself if it's a 1-to-1 profile extension for commercial users
  user_id CHAR(36) UNIQUE, -- FK to users table, should be NOT NULL if this is a profile
  nome VARCHAR(255) NOT NULL, -- Can be sourced from users table
  email VARCHAR(255) NOT NULL, -- Can be sourced from users table
  cargo VARCHAR(100),
  departamento VARCHAR(100),
  telefone VARCHAR(20), -- Can be sourced from a user_profiles table
  ativo TINYINT(1) DEFAULT 1,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL -- Or CASCADE if this record is dependent
);
CREATE INDEX idx_responsaveis_user_id ON responsaveis(user_id);
CREATE INDEX idx_responsaveis_email ON responsaveis(email);

-- Table: oportunidades
CREATE TABLE IF NOT EXISTS oportunidades (
  id CHAR(36) PRIMARY KEY,
  titulo VARCHAR(255) NOT NULL,
  cliente_id CHAR(36),
  valor DECIMAL(15,2),
  responsavel_id CHAR(36), -- FK to responsaveis.id (internal user/responsible for the opportunity)
  prazo DATE,
  status VARCHAR(50) NOT NULL DEFAULT 'novo_lead',
  descricao TEXT,
  data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Retained, could be same as created_at
  data_atualizacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- Retained, same as updated_at
  tipo VARCHAR(50) DEFAULT 'produto', -- e.g., produto ou servico
  tipo_faturamento VARCHAR(50) DEFAULT 'direto', -- e.g., direto ou distribuidor
  data_reuniao DATE,
  hora_reuniao TIME,
  posicao_kanban INT DEFAULT 0, -- Order in a Kanban board view
  motivo_perda TEXT,
  probabilidade INT DEFAULT 50, -- Percentage 0-100
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Added for consistency
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- Added for consistency
  FOREIGN KEY (cliente_id) REFERENCES clientes(id) ON DELETE CASCADE,
  FOREIGN KEY (responsavel_id) REFERENCES responsaveis(id) ON DELETE SET NULL
);
CREATE INDEX idx_oportunidades_cliente_id ON oportunidades(cliente_id);
CREATE INDEX idx_oportunidades_responsavel_id ON oportunidades(responsavel_id);
CREATE INDEX idx_oportunidades_status ON oportunidades(status);

-- Table: oportunidades_responsaveis (Junction table for multiple internal users per opportunity)
CREATE TABLE IF NOT EXISTS oportunidades_responsaveis (
  id CHAR(36) PRIMARY KEY,
  oportunidade_id CHAR(36),
  responsavel_id CHAR(36), -- FK to responsaveis.id
  papel VARCHAR(100), -- Role of this responsible person in this specific opportunity
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (oportunidade_id) REFERENCES oportunidades(id) ON DELETE CASCADE,
  FOREIGN KEY (responsavel_id) REFERENCES responsaveis(id) ON DELETE CASCADE,
  UNIQUE KEY uq_oportunidade_responsavel (oportunidade_id, responsavel_id) -- Ensure a responsible is not added twice to the same opportunity
);
CREATE INDEX idx_oportunidades_responsaveis_oportunidade_id ON oportunidades_responsaveis(oportunidade_id);
CREATE INDEX idx_oportunidades_responsaveis_responsavel_id ON oportunidades_responsaveis(responsavel_id);

-- Table: notas (Notes related to opportunities)
CREATE TABLE IF NOT EXISTS notas (
  id CHAR(36) PRIMARY KEY,
  oportunidade_id CHAR(36),
  autor_id CHAR(36), -- FK to users table (the user who wrote the note)
  texto TEXT NOT NULL,
  data TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Could be named created_at
  tipo VARCHAR(50) DEFAULT 'geral', -- e.g., geral, reuniao, negociacao
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Added for consistency
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- Added for consistency
  FOREIGN KEY (oportunidade_id) REFERENCES oportunidades(id) ON DELETE CASCADE,
  FOREIGN KEY (autor_id) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX idx_notas_oportunidade_id ON notas(oportunidade_id);
CREATE INDEX idx_notas_autor_id ON notas(autor_id);

-- Table: reunioes (Meetings related to opportunities)
CREATE TABLE IF NOT EXISTS reunioes (
  id CHAR(36) PRIMARY KEY,
  oportunidade_id CHAR(36),
  titulo VARCHAR(255) NOT NULL,
  data DATE NOT NULL,
  hora TIME NOT NULL,
  local VARCHAR(255),
  notas TEXT,
  concluida TINYINT(1) DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (oportunidade_id) REFERENCES oportunidades(id) ON DELETE CASCADE
);
CREATE INDEX idx_reunioes_oportunidade_id ON reunioes(oportunidade_id);
CREATE INDEX idx_reunioes_data ON reunioes(data);

-- Table: reunioes_participantes (Participants of meetings)
-- participante_id can refer to users.id (internal) or contatos.id (external client contact)
-- This requires careful handling in application logic or a more complex DB structure (e.g., a generic party model or separate tables for internal/external participants).
-- For simplicity, keeping as CHAR(36) and relying on tipo_participante.
CREATE TABLE IF NOT EXISTS reunioes_participantes (
  id CHAR(36) PRIMARY KEY,
  reuniao_id CHAR(36),
  participante_id CHAR(36), -- ID of the participant (from users or contatos table)
  tipo_participante VARCHAR(20) NOT NULL, -- e.g., 'interno' (users.id), 'externo' (contatos.id)
  confirmado TINYINT(1) DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (reuniao_id) REFERENCES reunioes(id) ON DELETE CASCADE
  -- Cannot add direct FK to participante_id without knowing the source table.
  -- Application logic must validate based on tipo_participante.
  -- Or, use two nullable FK columns: user_id and contato_id.
);
CREATE INDEX idx_reunioes_participantes_reuniao_id ON reunioes_participantes(reuniao_id);
CREATE INDEX idx_reunioes_participantes_participante_id ON reunioes_participantes(participante_id);


-- ======================================
-- VIEWS
-- ======================================

-- View: view_oportunidades
CREATE OR REPLACE VIEW view_oportunidades AS
SELECT
  o.id,
  o.titulo,
  o.valor,
  o.prazo,
  o.status,
  o.descricao AS oportunidade_descricao, -- aliased to avoid conflict if joined with other tables having 'descricao'
  o.data_criacao,
  o.data_atualizacao,
  o.tipo,
  o.tipo_faturamento,
  o.data_reuniao,
  o.hora_reuniao,
  o.posicao_kanban,
  o.probabilidade,
  o.motivo_perda,
  c.id AS cliente_id,
  c.nome AS cliente_nome,
  c.cnpj AS cliente_cnpj,
  c.contato_nome,
  c.contato_telefone,
  c.contato_email,
  c.segmento AS cliente_segmento,
  r.id AS responsavel_id,
  r.nome AS responsavel_nome,
  r.email AS responsavel_email,
  o.created_at,
  o.updated_at
FROM
  oportunidades o
  JOIN clientes c ON o.cliente_id = c.id
  LEFT JOIN responsaveis r ON o.responsavel_id = r.id;

-- View: view_cliente_contatos
CREATE OR REPLACE VIEW view_cliente_contatos AS
SELECT
  c.id AS cliente_id,
  c.nome AS cliente_nome,
  co.id AS contato_id,
  co.nome AS contato_nome,
  co.cargo,
  co.email AS contato_email, -- aliased
  co.telefone AS contato_telefone, -- aliased
  co.principal AS contato_principal -- aliased
FROM
  clientes c
  JOIN contatos co ON c.id = co.cliente_id;

-- View: view_reunioes
CREATE OR REPLACE VIEW view_reunioes AS
SELECT
  r.id AS reuniao_id, -- aliased
  r.titulo AS reuniao_titulo, -- aliased
  r.data AS reuniao_data, -- aliased
  r.hora AS reuniao_hora, -- aliased
  r.local AS reuniao_local, -- aliased
  r.notas AS reuniao_notas, -- aliased
  r.concluida AS reuniao_concluida, -- aliased
  r.created_at AS reuniao_created_at, -- aliased
  r.updated_at AS reuniao_updated_at, -- aliased
  o.id AS oportunidade_id,
  o.titulo AS oportunidade_titulo,
  c.id AS cliente_id,
  c.nome AS cliente_nome
FROM
  reunioes r
  JOIN oportunidades o ON r.oportunidade_id = o.id
  JOIN clientes c ON o.cliente_id = c.id;

-- ======================================
-- NOTES ON FUNCTIONS AND PROCEDURES
-- ======================================

-- The following PostgreSQL function needs manual conversion to a MySQL Stored Procedure:
--
-- CREATE OR REPLACE FUNCTION crmonefactory.atualizar_status_oportunidade(
--   oportunidade_id UUID,
--   novo_status TEXT
-- )
-- RETURNS BOOLEAN
-- LANGUAGE plpgsql
-- SECURITY DEFINER
-- AS $$
-- BEGIN
--   UPDATE crmonefactory.oportunidades
--   SET
--     status = novo_status,
--     data_atualizacao = NOW() -- In MySQL, this would be CURRENT_TIMESTAMP
--   WHERE id = oportunidade_id;
--
--   RETURN FOUND; -- MySQL does not have a direct `FOUND` equivalent in the same way for return.
--                 -- ROW_COUNT() can be checked. A procedure might not return a boolean directly,
--                 -- or it could use an OUT parameter.
-- END;
-- $$;
--
-- Example structure for MySQL procedure (conceptual):
--
-- DELIMITER //
-- CREATE PROCEDURE atualizar_status_oportunidade(
--   IN p_oportunidade_id CHAR(36),
--   IN p_novo_status VARCHAR(255),
--   OUT p_success TINYINT(1)
-- )
-- BEGIN
--   DECLARE row_count_val INT;
--   UPDATE oportunidades
--   SET
--     status = p_novo_status,
--     data_atualizacao = CURRENT_TIMESTAMP, -- or updated_at = CURRENT_TIMESTAMP if that's the column being used
--     updated_at = CURRENT_TIMESTAMP
--   WHERE id = p_oportunidade_id;
--
--   SET row_count_val = ROW_COUNT();
--   IF row_count_val > 0 THEN
--     SET p_success = 1;
--   ELSE
--     SET p_success = 0;
--   END IF;
-- END //
-- DELIMITER ;

-- ======================================
-- Additional Notes:
-- ======================================
-- 1. `uuid-ossp` extension is PostgreSQL specific and not used. UUIDs are CHAR(36) and expected to be application-generated.
-- 2. Schema prefix `crmonefactory.` has been removed. Assumes connection to the correct database.
-- 3. `BEGIN;` and `COMMIT;` removed.
-- 4. `GRANT` statements omitted.
-- 5. `created_at` and `updated_at` columns:
--    - Added `created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP` where it was missing for consistency.
--    - Ensured `updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` for tables that had it.
--    - Some tables in the source had `data_criacao` and `data_atualizacao`. I've kept these but also added standard `created_at`/`updated_at` for ORM compatibility and consistency.
--      If `data_criacao` is meant to be `created_at`, it can be aliased or consolidated. Similarly for `data_atualizacao`.
-- 6. `clientes.segmento`: Currently VARCHAR. If `segmentos_clientes` table is the definitive source, this could be a FK.
-- 7. `clientes.faturamento`: Currently VARCHAR. If this is a monetary value, DECIMAL or INT might be better.
-- 8. `responsaveis` table: Added a note about its potential redundancy with the main `users` table. If it acts as a specific "commercial profile" for users, then `user_id` should ideally be `NOT NULL` and `UNIQUE`.
-- 9. `reunioes_participantes.participante_id`: Noted the challenge of a polymorphic FK. Application logic will need to manage this, or the table structure could be changed (e.g. two nullable FKs, one to `users` and one to `contatos`).
-- 10. Indexes: Added some basic indexes for foreign keys and commonly queried columns. More specific indexing strategies might be needed based on query patterns.
-- 11. View column name aliasing: Added aliases in views where column names might conflict (e.g., `descricao`, `email`, `telefone`, `id`, `titulo`, `data`, `hora`, `local`, `notas`, `concluida`, `created_at`, `updated_at`) to make them unique when selecting from the view.
-- 12. `oportunidades.responsavel_id` links to `responsaveis(id)`. This seems correct based on the schema.
-- 13. `oportunidades_responsaveis` also links to `responsaveis(id)`.

/*
-- Example of how to insert a UUID in MySQL 8.0+ if needed (or generate in app):
-- INSERT INTO clientes (id, nome, cnpj, responsavel_interno)
-- VALUES (UUID(), 'Test Cliente', '00.000.000/0001-00', 'user-uuid-from-users-table');
*/

-- Content from documentos_mysql.sql
-- MySQL DDL for Documentos Module Tables

-- Table: documentos
CREATE TABLE IF NOT EXISTS documentos (
  id CHAR(36) PRIMARY KEY,
  nome TEXT NOT NULL,
  tipo TEXT NOT NULL, -- Type of the document, e.g., 'contrato', 'edital'
  -- The `categorias text[]` column from PostgreSQL is replaced by the tags & documentos_tags tables.
  categoria TEXT NULL, -- Legacy single category field, kept for compatibility
  descricao TEXT,
  licitacao_id CHAR(36), -- FK to licitacoes table
  numero_documento TEXT,
  data_validade TIMESTAMP NULL, -- Nullable, as not all documents might have an expiry date
  url_documento TEXT, -- URL if stored externally
  arquivo_path TEXT, -- Path if stored in a local/shared filesystem
  formato TEXT, -- e.g., 'pdf', 'docx'
  tamanho BIGINT, -- Size in bytes
  status TEXT NOT NULL DEFAULT 'ativo', -- e.g., 'ativo', 'arquivado', 'excluido'
  criado_por CHAR(36), -- FK to users table
  data_criacao TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  data_atualizacao TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (licitacao_id) REFERENCES licitacoes(id) ON DELETE SET NULL, -- Assuming licitacoes table exists
  FOREIGN KEY (criado_por) REFERENCES users(id) ON DELETE SET NULL -- Assuming users table exists
);

-- Indexes for documentos table
CREATE INDEX idx_documentos_licitacao ON documentos(licitacao_id);
CREATE INDEX idx_documentos_status ON documentos(status);
CREATE INDEX idx_documentos_tipo ON documentos(tipo(255)); -- Prefix for TEXT column indexing
CREATE INDEX idx_documentos_criado_por ON documentos(criado_por);
CREATE INDEX idx_documentos_data_criacao ON documentos(data_criacao);

-- Table: tags (replaces the array `categorias`)
CREATE TABLE IF NOT EXISTS tags (
  id CHAR(36) PRIMARY KEY,
  nome VARCHAR(100) NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Table: documentos_tags (join table for many-to-many relationship between documentos and tags)
CREATE TABLE IF NOT EXISTS documentos_tags (
  documento_id CHAR(36) NOT NULL,
  tag_id CHAR(36) NOT NULL,
  PRIMARY KEY (documento_id, tag_id),
  FOREIGN KEY (documento_id) REFERENCES documentos(id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);
CREATE INDEX idx_documentos_tags_documento_id ON documentos_tags(documento_id);
CREATE INDEX idx_documentos_tags_tag_id ON documentos_tags(tag_id);

-- ======================================
-- NOTES ON FUNCTIONS AND TRIGGERS
-- ======================================

-- 1. Trigger `documentos_atualizar_timestamp`:
--    The PostgreSQL trigger function `crmonefactory.documentos_atualizar_timestamp`
--    is replaced by MySQL's native `ON UPDATE CURRENT_TIMESTAMP` feature for the
--    `data_atualizacao` column in the `documentos` table.

-- 2. PostgreSQL Functions for Category Search:
--    The following PostgreSQL functions need to be re-implemented using SQL JOINs
--    with the new `tags` and `documentos_tags` tables in MySQL:
--
--    - `crmonefactory.documentos_por_categoria(categoria_busca text)`
--      -- MySQL equivalent:
--      -- SELECT d.* FROM documentos d
--      -- JOIN documentos_tags dt ON d.id = dt.documento_id
--      -- JOIN tags t ON dt.tag_id = t.id
--      -- WHERE t.nome = 'categoria_busca' AND d.status != 'excluido';
--
--    - `crmonefactory.documentos_com_qualquer_categoria(categorias_busca text[])`
--      -- MySQL equivalent (assuming 'categorias_busca' is a list of tag names):
--      -- SELECT DISTINCT d.* FROM documentos d
--      -- JOIN documentos_tags dt ON d.id = dt.documento_id
--      -- JOIN tags t ON dt.tag_id = t.id
--      -- WHERE t.nome IN ('cat1', 'cat2', ...) AND d.status != 'excluido';
--
--    - `crmonefactory.documentos_com_todas_categorias(categorias_busca text[])`
--      -- MySQL equivalent (assuming 'categorias_busca' is a list of tag names and count_of_categories is known):
--      -- SELECT d.* FROM documentos d
--      -- JOIN documentos_tags dt ON d.id = dt.documento_id
--      -- JOIN tags t ON dt.tag_id = t.id
--      -- WHERE t.nome IN ('cat1', 'cat2', ...) AND d.status != 'excluido'
--      -- GROUP BY d.id
--      -- HAVING COUNT(DISTINCT t.nome) = count_of_categories;

-- ======================================
-- Additional Notes:
-- ======================================
-- 1. UUIDs: `CHAR(36)` is used. Application is responsible for generating UUIDs.
-- 2. Timestamps: `TIMESTAMPTZ` converted to `TIMESTAMP`.
-- 3. Schema Prefix: `crmonefactory.` removed.
-- 4. RLS Policies: Ignored for DDL.
-- 5. `categorias text[]`: This PostgreSQL array column is handled by the new `tags` and `documentos_tags` tables.
--    The legacy `categoria TEXT NULL` column has been retained in the `documentos` table for compatibility if needed during a phased migration.
--    Data from `categoria` or `categorias[]` would need to be migrated to the new `tags` structure manually or via script.
-- 6. Foreign Key `criado_por`: Points to `users(id)`. Assumes `users` table exists.
-- 7. Foreign Key `licitacao_id`: Points to `licitacoes(id)`. Assumes `licitacoes` table exists. If not, this FK should be removed or the `licitacoes` table DDL created.
-- 8. Indexing on `TEXT` columns (`tipo`): A prefix length (e.g., 255) is specified as MySQL may require this for indexing `TEXT` or `BLOB` columns.
-- 9. The GIN index `idx_documentos_categorias ON crmonefactory.documentos USING GIN (categorias)` is specific to PostgreSQL arrays and is replaced by standard B-tree indexes on the `documentos_tags` join table.
-- 10. `auth.users(id)` reference for `criado_por` in the source schema has been interpreted as the main `users` table.
-- 11. Default for `data_criacao` and `data_atualizacao` are set to `CURRENT_TIMESTAMP`. `data_atualizacao` also has `ON UPDATE CURRENT_TIMESTAMP`.
-- 12. `status` column in `documentos` is kept as `TEXT`. Consider `VARCHAR(50)` or an `ENUM` if the possible values are well-defined and limited.
-- 13. `tipo` column in `documentos` is kept as `TEXT`. Similar to `status`, `VARCHAR(100)` or `ENUM` could be alternatives.

/*
-- Example of how to insert a document and associate tags in MySQL:
-- -- 1. Insert the document:
-- INSERT INTO documentos (id, nome, tipo, criado_por, licitacao_id)
-- VALUES (UUID(), 'Contrato XPTO', 'Contrato', 'user-uuid', 'licitacao-uuid');
-- SET @last_doc_id = LAST_INSERT_ID(); -- If using auto-increment ID, or get the UUID generated by app.

-- -- 2. Ensure tags exist or create them:
-- INSERT IGNORE INTO tags (id, nome) VALUES (UUID(), 'juridico');
-- SET @tag_juridico_id = (SELECT id FROM tags WHERE nome = 'juridico');
-- INSERT IGNORE INTO tags (id, nome) VALUES (UUID(), 'licitacao_xyz');
-- SET @tag_licitacao_id = (SELECT id FROM tags WHERE nome = 'licitacao_xyz');

-- -- 3. Associate document with tags:
-- INSERT INTO documentos_tags (documento_id, tag_id) VALUES (@last_doc_id, @tag_juridico_id);
-- INSERT INTO documentos_tags (documento_id, tag_id) VALUES (@last_doc_id, @tag_licitacao_id);
*/

SET FOREIGN_KEY_CHECKS=1; -- Re-enable foreign key checks
